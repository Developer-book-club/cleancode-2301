# Chapter 13. 동시성

#### 동시성이 필요한 이유?
- 동시성은 결합(coupling)을 없애는 전략이다. 즉, 무엇과 언제를 분리하는 전략이다. 스레드가 하나인 프로그램은 무엇과 언제가 서로 밀접하다.

##### __ 미신과 오해
- 동시성은 항상이 아니라 때로 성능을 높여준다.
- 단일 스레드 시스템과 다중 스레드 시스템은 설계가 판이하게 다르다. 일반적으로 무엇과 언제를 분리하면 시스템 구조가 크게 달라진다.
- 실제로 컨테이너가 어떻게 동작하는지, 어떻게 동시 수정, 데드랑 등과 같은 문제를 피할 수 있는지 알아야 한다.
- 동시성은 다소 부하를 유발한다.
- 동시성은 복잡하다.
- 일반적으로 동시성 버그는 재현하기 어렵다.
- 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.

#### 난관
- 두 스레드가 코드 한 줄을 거쳐가는 경로는 수없이 많은데, 그 중에서 일부 경로가 잘못된 결과를 내놓는 경우가 생긴다.

#### 동시성 방어 원칙

##### __ 단일 책임 원칙Single Responsibility Principle, SRP
- SRP는 주어진 메서드/클래스/컴포넌트를 변경할 이유가 하나여야 한다는 원칙이다.
- 동시성 관련 코드는 다른 코드와 분리하라.

##### __ 따름 정리corollary: 자료 범위를 제한하라
- 공유 객체를 사용하는 코드 내 critical section을 synchronized 키워드로 보호라길 권장한다.
- 자료를 캡슐화(Encapsulaltion)하라. 공유 자료를 최대한 줄이라.

##### __ 따름 정리: 자료 사본을 사용하라
- 객체를 복사해 읽기 전용으로 사용하는 방법이 가능하다.
- 각 스레드가 객체를 복사해 사용한 후 한 스레드가 해당 사본에서 결과를 가져오는 방법도 가능하다.

##### __ 따름 정리: 스레드는 가능한 독립적으로 구현하라
- 다른 스레드와 자료를 공유하지 않는다. 
- 각 스레드는 클라이언트 요청 하나를 처리한다.
- 모든 정보는 비공유 출처에서 가져오며 로컬 변수에 저장한다.
- 독자적인 스레드로, 가능하면 다른 프로세서에서, 돌려도 괜찮도록 자료를 독립적인 단위로 분할하라.

#### 라이브러리를 이해하라

##### __ 스레드 환경에 안전한 컬렉션
- 언어가 제공하는 클래스를 검토하라.

#### 실행 모델을 이해하라
- 한정된 자원(Bound Resource): 다중 스레드 환경에서 사용하는 자원으로, 크기나 숫자가 제한적이다. ex) Database 연결, 길이가 일정한 읽기/쓰기 버퍼 등
- 상호 배제(Mutual Exclusion): 한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우를 가리킨다.
- 기아(Starvation): 한 스레드나 여러 스레드가 굉장히 오랫동안 혹은 영원히 자원을 기다린다. ex) 항상 짧은 스레드에게 우선순위를 준다면, 짧은 스레드가 지속으로 이어질 경우, 긴 스레드가 기아 상태에 빠진다.
- 데드락(Deadlock): 여러 스레드가 서로가 끝나기를 기다린다. 모든 스레드가 각기 필요한 자원을 다른 스레드가 점유하는 바람에 어느 쪽도 더 이상 진행하지 못한다.
- 라이브락(Livelock): 락을 거는 단계에서 각 스레드가 서로를 방해한다. 스레드는 계속해서 진행하려 하지만, 공명(resonance)으로 인해, 굉장히 오랫동안 혹은 영원히 진행하지 못한다.

##### __ 생산자-소비자Producer-Consumer
- 생산자 스레드가 정보를 생성해 buffer나 queue에 넣는다.
- 소비자 스레드가 queue에서 정보를 가져와 사용한다.
- 생산자와 소비자 스레드가 사용하는 대기열(queue)는 한정된 자원이다.
- 잘못하면 생산자 스레드와 소비자 스레드가 둘 다 진행 가능함에도 불구하고 동시에 서로에게서 시그널을 기다릴 가능성이 존재한다.

##### __ 읽기-쓰기Readers-Writers
- 읽기 스레드가 없을 때까지 갱신을 원하는 쓰기 스레드가 버퍼를 기다리는 방법. 읽기 스레드가 계속 이어진다면 쓰기 스레드는 기아 상태에 빠진다.
- 반면 쓰기 스레드에게 우선권을 준 상태에서 쓰기 스레드가 계속 이어진다면 처리율이 떨어진다.
- 양쪽 균형을 잡으면서 동시 갱신 문제를 피하는 해법이 필요하다.

##### __ 식사하는 철학자들Dining Philosophers
- 기업 애플리케이션은 여러 프로세스가 자원을 얻으려 경쟁한다. 주의해서 설계하지 않으면 데드락, 라이브락, 처리율 저하, 효율성 저하 등을 겪는다.
- 각 알고리즘과 각 해법을 직접 구현해보고 이해하라.

#### 동기화하는 메서드 사이에 존재하는 의존성을 이해하라
- 공유 객체 하나에는 메서드 하나만 사용하는 것을 권장한다.
- 공유 객체 하나에 여러 메서드가 필요한 상황도 생긴다.
  - 클라이언트에서의 잠금
  - 서버에서 잠금
  - 연결(Adapted) 서버

#### 동기화하는 부분을 작게 만들어라
- synchronized 키워드를 사용하면 lock을 설정한다. 같은 lock으로 감싼 모든 코드 영역은 한 번에 한 Thread만 실행이 가능하다.
- lock은 Thread를 지연시키고 부하를 가중시킨다. 그러므로 synchronized문을 남발하는 코드는 바람직하지 않다.
- 반면 critical section은 반드시 보호해야 한다. 따라서 critical section 수를 최대한 줄여야 한다.

#### 올바른 종료 코드는 구현하기 어렵다
- 이미 나온 알고리즘을 검토하라.

#### 스레드 코드 테스트하기
- 문제를 노출하는 테스트 케이스를 작성하라. 
- 프로그램 설정과 시스템 설정과 부하를 바꿔가며 자주 돌려라.
- 테스트가 실패하면 원인을 추적하라.

##### __ 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라
- 시스템 실패를 '일회성'이라 치부하지 마라.

##### __ 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자
- 스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 동시에 디버깅하지 마라. 먼저 스레드 환경 밖에서 코드를 올바로 돌려라.

##### __ 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라
- 한 스레드로 실행하거나, 여러 스레드로 실행하거나, 실행 중 스레드 수를 바꿔본다.
- 스레드 코드를 실제 환경이나 테스트 환경에서 돌려본다.
- 테스트 케이스를 작성한다.
- 다양한 설정에서 실행할 목적으로 다른 환경에 쉽게 끼워 넣을 수 있게 코드를 구현하라.

##### __ 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라
- 스레드 개수를 조율하기 쉽게 코드를 구현한다.
- 프로그램이 돌아가는 도중에 스레드 개수를 변경하는 방법도 고려한다.

##### __ 프로세서 수보다 많은 스레드를 돌려보라
- 시스템이 스레드를 swapping할 때도 문제가 발생한다. swapping을 일으키려면 프로세서 수보다 많은 스레드를 돌린다. swapping이 잦을수록 critical section을 빼먹은 코드나 데드락을 일으키는 코드를 찾기 쉬워진다.

##### __ 다른 플랫폼에서 돌려보라
- 다중 스레드 코드는 플랫폼에 따라 다르게 돌아간다.
- 처음부터 그리고 자주 모든 목표 플랫폼에서 코드를 돌려라.

##### __ 코드에 보조 코드instrument를 넣어 돌려라. 강제로 실패를 일으키게 해보라
- Object.wait(), Object.sleep(), Object.yield(), Object.priority()

##### __ 직접 구현하기
- 코드에다 직접 wait(), sleep(), yield(), priority() 함수를 추가한다.
- 배포 환경이 아니라 테스트 환경에서 보조 코드를 실행할 방법이 필요하다.
- 실행할 때마다 설정을 바꿔줄 방법도 필요하다.
- 스레드를 전혀 모르는 POJO와 스레드를 제어하는 클래스로 프로그램을 분할하면 보조 코드를 추가할 위치를 찾기가 쉬워진다.

##### __ 자동화
```java
public synchronized String nextUrlOrNull()
{
  if (hasNext())
  {
    ThreadJigglePoint.jiggle();
    Stringurl = urlGenerator.next();
    ThreadJigglePoint.jiggle();
    updateHasNext();
    ThreadJigglePoint.jiggle();
    return url;
  }
}
```
- ThreadJigglePoint.jiggle() 호출은 무작위로 sleep이나 yield를 호출한다. 때로는 아무 동작도 하지 않는다.
- ThreadJigglePoint 클래스를 두 가지로 구현하면 편리하다.
  - 하나는 jiggle() 메서드를 비워두고 배포 환경에서 사용한다.
  - 다른 하나는 무작위로 nop, sleep이나 yield 등을 테스트 환경에서 수행한다.
- 코드를 흔드는(jiggle) 이유는 스레드를 매번 다른 순서로 실행하기 위해서다. 좋은 테스트 케이스와 jiggling 기법은 오류가 드러날 확률을 크게 높여준다.
- jiggling 기법을 사용해 오류를 찾아내라.


